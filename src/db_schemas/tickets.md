-- === Enum types (idempotent) ===
DO $$
BEGIN
  CREATE TYPE public.ticket_status AS ENUM ('Open', 'In Progress', 'Closed');
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$
BEGIN
  CREATE TYPE public.ticket_priority AS ENUM ('Low', 'Medium', 'High');
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- === Ensure the timestamp trigger function exists (safe no-op if it does) ===
DO $$
BEGIN
  PERFORM 1 FROM pg_proc p
  JOIN pg_namespace n ON n.oid = p.pronamespace
  WHERE p.proname = 'set_updated_at' AND n.nspname = 'public';

  IF NOT FOUND THEN
    CREATE OR REPLACE FUNCTION public.set_updated_at()
    RETURNS trigger
    LANGUAGE plpgsql
    AS $f$
    BEGIN
      NEW.updated_at := NOW();
      RETURN NEW;
    END;
    $f$;
  END IF;
END $$;


-- === Tickets table ===
CREATE TABLE IF NOT EXISTS public.tickets (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES public."user"(id) ON DELETE CASCADE,
  organisation_id BIGINT NOT NULL REFERENCES public.organisations(id) ON DELETE CASCADE,
  subject TEXT NOT NULL,
  description TEXT,
  status public.ticket_status NOT NULL DEFAULT 'Open',
  priority public.ticket_priority NOT NULL DEFAULT 'Medium',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  resolved_at TIMESTAMPTZ
);




-- Trigger to auto-update updated_at
CREATE OR REPLACE TRIGGER set_tickets_updated_at
BEFORE UPDATE ON public.tickets
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at();

-- Helpful indexes for RLS/joins
CREATE INDEX IF NOT EXISTS idx_tickets_user_id ON public.tickets(user_id);
CREATE INDEX IF NOT EXISTS idx_tickets_organisation_id ON public.tickets(organisation_id);
CREATE INDEX IF NOT EXISTS idx_tickets_status ON public.tickets(status);
CREATE INDEX IF NOT EXISTS idx_tickets_priority ON public.tickets(priority);

-- === RLS for tickets ===
ALTER TABLE public.tickets ENABLE ROW LEVEL SECURITY;


-- Ticket owner can see their ticket
CREATE POLICY "tickets_select_owner"
ON public.tickets FOR SELECT
USING (
  auth.uid() = (SELECT u.user_uuid FROM public."user" u WHERE u.id = user_id)
);



-- Org admins can view all tickets in their org
CREATE POLICY "tickets_select_org_admins"
ON public.tickets FOR SELECT
USING (
  EXISTS (
    SELECT 1
    FROM public.user_organisations uo
    JOIN public."user" u ON uo.user_id = u.id
    WHERE u.user_uuid = auth.uid()
      AND uo.organisation_id = u.organisation_id
  )
);



-- Super admins can manage all tickets
CREATE POLICY "tickets_all_super_admins"
ON public.tickets FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM public."user" u
    WHERE u.user_uuid = auth.uid() AND u.user_type = 3
  )
);




-- Users can create their own tickets (user_id must be theirs)
CREATE POLICY "tickets_insert_owner"
ON public.tickets FOR INSERT
WITH CHECK (
  auth.uid() = (SELECT u.user_uuid FROM public."user" u WHERE u.id = user_id)
);

-- Org admins may create tickets within their org
CREATE POLICY "tickets_insert_org_admins"
ON public.tickets FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1
    FROM public.user_organisations uo
    JOIN public."user" u ON uo.user_id = u.id
    WHERE u.user_uuid = auth.uid()
      AND uo.organisation_id = u.organisation_id
  )
);

-- Owners can update their own tickets (but cannot change organisation_id or user_id)
CREATE POLICY "tickets_update_owner"
ON public.tickets FOR UPDATE
USING (
  auth.uid() = (SELECT u.user_uuid FROM public."user" u WHERE u.id = user_id)
)
WITH CHECK (
  auth.uid() = (SELECT u.user_uuid FROM public."user" u WHERE u.id = user_id)
  AND organisation_id = (SELECT t.organisation_id FROM public.tickets t WHERE t.id = id)
  AND user_id = (SELECT t.user_id FROM public.tickets t WHERE t.id = id)
);

-- Org admins can update tickets in their org
CREATE POLICY "tickets_update_org_admins"
ON public.tickets FOR UPDATE
USING (
  EXISTS (
    SELECT 1
    FROM public.user_organisations uo
    JOIN public."user" u ON uo.user_id = u.id
    WHERE u.user_uuid = auth.uid()
      AND uo.organisation_id = u.organisation_id
  )
)
WITH CHECK (
  EXISTS (
    SELECT 1
    FROM public.user_organisations uo
    JOIN public."user" u ON uo.user_id = u.id
    WHERE u.user_uuid = auth.uid()
      AND uo.organisation_id = u.organisation_id
  )
);

-- Optional: allow owners to delete their tickets (omit if you don't want this)
CREATE POLICY "tickets_delete_owner"
ON public.tickets FOR DELETE
USING (
  auth.uid() = (SELECT u.user_uuid FROM public."user" u WHERE u.id = user_id)
);

-- === Ticket messages ===
CREATE TABLE IF NOT EXISTS public.ticket_messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ticket_id BIGINT NOT NULL REFERENCES public.tickets(id) ON DELETE CASCADE,
  user_id BIGINT NOT NULL REFERENCES public."user"(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_ticket_messages_ticket_id ON public.ticket_messages(ticket_id);
CREATE INDEX IF NOT EXISTS idx_ticket_messages_user_id ON public.ticket_messages(user_id);

-- RLS for messages
ALTER TABLE public.ticket_messages ENABLE ROW LEVEL SECURITY;

-- Participants (ticket owner or org admins) can read messages
CREATE POLICY "ticket_messages_select_participants"
ON public.ticket_messages FOR SELECT
USING (
  -- Ticket owner
  auth.uid() = (
    SELECT u.user_uuid
    FROM public."user" u
    WHERE u.id = (SELECT t.user_id FROM public.tickets t WHERE t.id = ticket_id)
  )
  OR
  -- Org admin of the ticket's org
  EXISTS (
    SELECT 1
    FROM public.user_organisations uo
    JOIN public."user" u ON uo.user_id = u.id
    WHERE u.user_uuid = auth.uid()
      AND uo.organisation_id = (SELECT t.organisation_id FROM public.tickets t WHERE t.id = ticket_id)
  )
);

-- Users can add messages only to tickets they own (and must set user_id to themselves)
CREATE POLICY "ticket_messages_insert_owner_ticket"
ON public.ticket_messages FOR INSERT
WITH CHECK (
  -- user_id belongs to caller
  auth.uid() = (SELECT u.user_uuid FROM public."user" u WHERE u.id = user_id)
  -- and they own the ticket they are posting to
  AND user_id = (SELECT t.user_id FROM public.tickets t WHERE t.id = ticket_id)
);

-- Org admins can add messages to tickets in their org (and must set user_id to themselves)
CREATE POLICY "ticket_messages_insert_org_admin"
ON public.ticket_messages FOR INSERT
WITH CHECK (
  auth.uid() = (SELECT u.user_uuid FROM public."user" u WHERE u.id = user_id)
  AND EXISTS (
    SELECT 1
    FROM public.user_organisations uo
    JOIN public."user" u ON uo.user_id = u.id
    WHERE u.user_uuid = auth.uid()
      AND uo.organisation_id = (SELECT t.organisation_id FROM public.tickets t WHERE t.id = ticket_id)
  )
);

-- (Optional) Allow authors to delete their own messages; admins covered by super-admin policy
CREATE POLICY "ticket_messages_delete_author"
ON public.ticket_messages FOR DELETE
USING (
  auth.uid() = (SELECT u.user_uuid FROM public."user" u WHERE u.id = user_id)
);

-- Super admins manage all messages (already covered above by ALL)
CREATE POLICY "ticket_messages_all_super_admins"
ON public.ticket_messages FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM public."user" u
    WHERE u.user_uuid = auth.uid() AND u.user_type = 3
  )
);
