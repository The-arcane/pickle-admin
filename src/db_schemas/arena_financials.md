-- Trigger helper (reuse for all tables needing updated_at)
create or replace function public.set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at := now();
  return new;
end; $$;

CREATE TABLE public.bank_details (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    organisation_id BIGINT NOT NULL UNIQUE
        REFERENCES public.organisations(id) ON DELETE CASCADE,
    bank_name TEXT NOT NULL,
    account_holder_name TEXT NOT NULL,
    account_number_encrypted BYTEA NOT NULL,  -- encrypted using pgsodium
    ifsc_code TEXT NOT NULL
        CHECK (ifsc_code ~* '^[A-Z]{4}0[A-Z0-9]{6}$'),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Trigger to auto-update updated_at
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$;
DROP TRIGGER IF EXISTS trg_bank_details_updated ON public.bank_details;
CREATE TRIGGER trg_bank_details_updated
BEFORE UPDATE ON public.bank_details
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- Enable RLS
ALTER TABLE public.bank_details ENABLE ROW LEVEL SECURITY;

-- RLS policies
CREATE POLICY "bank_details_select"
ON public.bank_details
FOR SELECT USING (
  EXISTS (
    SELECT 1
    FROM public.user_organisations uo
    JOIN public.user u ON u.id = uo.user_id
    WHERE u.user_uuid = auth.uid()
      AND uo.organisation_id = bank_details.organisation_id
  )
);


CREATE POLICY "bank_details_write"
ON public.bank_details
FOR ALL
USING (
  EXISTS (
    SELECT 1
    FROM public.user_organisations uo
    JOIN public.user u ON u.id = uo.user_id
    WHERE u.user_uuid = auth.uid()
      AND uo.organisation_id = bank_details.organisation_id
  )
)
WITH CHECK (
  EXISTS (
    SELECT 1
    FROM public.user_organisations uo
    JOIN public.user u ON u.id = uo.user_id
    WHERE u.user_uuid = auth.uid()
      AND uo.organisation_id = bank_details.organisation_id
  )
);

do $$ begin
  create type public.payout_status as enum ('Pending', 'Completed', 'Failed');
exception when duplicate_object then null; end $$;

create table if not exists public.payouts (
  id bigint generated by default as identity primary key,
  organisation_id bigint not null
    references public.organisations(id) on delete cascade,
  amount numeric(12,2) not null check (amount > 0),
  status public.payout_status not null default 'Pending',
  requested_at timestamptz not null default now(),
  processed_at timestamptz,
  bank_transaction_id text,
  notes text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  check (processed_at is null or processed_at >= requested_at)
);

create index if not exists idx_payouts_org on public.payouts(organisation_id);
create index if not exists idx_payouts_status on public.payouts(status);
create index if not exists idx_payouts_requested_at on public.payouts(requested_at);
create unique index if not exists uidx_payouts_bank_txn_id
  on public.payouts(bank_transaction_id)
  where bank_transaction_id is not null;

drop trigger if exists trg_payouts_updated on public.payouts;
create trigger trg_payouts_updated
before update on public.payouts
for each row execute function public.set_updated_at();

alter table public.payouts enable row level security;

-- RLS
create policy "payouts_select"
on public.payouts for select using (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = payouts.organisation_id
  )
);

create policy "payouts_write"
on public.payouts for insert with check (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = payouts.organisation_id
  )
);

create policy "payouts_update_delete"
on public.payouts for update using (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = payouts.organisation_id
  )
) with check (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = payouts.organisation_id
  )
);

do $$ begin
  create type public.transaction_type as enum ('Credit', 'Debit');
  create type public.transaction_category as enum ('Booking Fee', 'Event Fee', 'Payout', 'Refund', 'Platform Fee', 'Other');
exception when duplicate_object then null; end $$;

create table if not exists public.ledger_entries (
  id bigint generated by default as identity primary key,
  organisation_id bigint not null references public.organisations(id) on delete cascade,
  type public.transaction_type not null,
  category public.transaction_category not null,
  amount numeric(12,2) not null check (amount > 0),
  description text not null,
  related_booking_id bigint references public.bookings(id) on delete set null,
  related_event_booking_id bigint references public.event_bookings(id) on delete set null,
  related_payout_id bigint references public.payouts(id) on delete set null,
  created_at timestamptz not null default now()
);

create index if not exists idx_ledger_entries_org on public.ledger_entries(organisation_id);
create index if not exists idx_ledger_entries_category on public.ledger_entries(category);
create index if not exists idx_ledger_entries_booking on public.ledger_entries(related_booking_id);
create index if not exists idx_ledger_entries_event on public.ledger_entries(related_event_booking_id);
create index if not exists idx_ledger_entries_payout on public.ledger_entries(related_payout_id);

alter table public.ledger_entries enable row level security;

create policy "ledger_entries_select"
on public.ledger_entries for select using (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = ledger_entries.organisation_id
  )
);

create policy "ledger_entries_insert"
on public.ledger_entries for insert with check (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = ledger_entries.organisation_id
  )
);

create policy "ledger_entries_update_delete"
on public.ledger_entries for update using (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = ledger_entries.organisation_id
  )
) with check (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = ledger_entries.organisation_id
  )
);

do $$ begin
  create type public.invoice_status as enum ('Draft', 'Sent', 'Paid', 'Pending', 'Overdue', 'Cancelled');
exception when duplicate_object then null; end $$;

create table if not exists public.invoices (
  id bigint generated by default as identity primary key,
  organisation_id bigint not null references public.organisations(id) on delete cascade,
  user_id bigint not null references public.user(id) on delete cascade,
  gateway_transaction_id bigint references public.transactions(id) on delete set null, -- optional link
  invoice_number varchar(50) unique, -- generate & enforce in app/DB function
  status public.invoice_status not null default 'Draft',
  currency varchar(10) not null default 'INR',
  total_amount numeric(12,2) not null check (total_amount >= 0),
  issue_date date not null default current_date,
  due_date date not null,
  paid_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  check (due_date >= issue_date)
);

create index if not exists idx_invoices_org on public.invoices(organisation_id);
create index if not exists idx_invoices_user on public.invoices(user_id);
create index if not exists idx_invoices_status on public.invoices(status);
create index if not exists idx_invoices_dates on public.invoices(issue_date, due_date);

drop trigger if exists trg_invoices_updated on public.invoices;
create trigger trg_invoices_updated
before update on public.invoices
for each row execute function public.set_updated_at();

create table if not exists public.invoice_items (
  id bigint generated by default as identity primary key,
  invoice_id bigint not null references public.invoices(id) on delete cascade,
  description text not null,
  quantity integer not null default 1 check (quantity > 0),
  unit_price numeric(12,2) not null check (unit_price >= 0),
  total_price numeric(12,2) generated always as (quantity * unit_price) stored
);

create index if not exists idx_invoice_items_invoice on public.invoice_items(invoice_id);

alter table public.invoices enable row level security;
alter table public.invoice_items enable row level security;

-- Invoices RLS
create policy "invoices_select"
on public.invoices for select using (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = invoices.organisation_id
  )
);

create policy "invoices_insert"
on public.invoices for insert with check (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = invoices.organisation_id
  )
);

create policy "invoices_update_delete"
on public.invoices for update using (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = invoices.organisation_id
  )
) with check (
  exists (
    select 1 from public.user_organisations uo
    join public.user u on u.id = uo.user_id
    where u.user_uuid = auth.uid()
      and uo.organisation_id = invoices.organisation_id
  )
);

-- Invoice items RLS (scope via parent invoice)
create policy "invoice_items_all_via_invoice"
on public.invoice_items
for all
using (
  exists (
    select 1
    from public.invoices i
    join public.user_organisations uo on uo.organisation_id = i.organisation_id
    join public.user u on u.id = uo.user_id
    where i.id = invoice_items.invoice_id
      and u.user_uuid = auth.uid()
  )
) with check (
  exists (
    select 1
    from public.invoices i
    join public.user_organisations uo on uo.organisation_id = i.organisation_id
    join public.user u on u.id = uo.user_id
    where i.id = invoice_items.invoice_id
      and u.user_uuid = auth.uid()
  )
);

-- Function to get the current balance of an organization
CREATE OR REPLACE FUNCTION get_organisation_balance(p_organisation_id bigint)
RETURNS numeric AS $$
DECLARE
    total_credit numeric;
    total_debit numeric;
BEGIN
    SELECT COALESCE(SUM(amount), 0)
    INTO total_credit
    FROM public.ledger_entries
    WHERE organisation_id = p_organisation_id AND type = 'Credit';

    SELECT COALESCE(SUM(amount), 0)
    INTO total_debit
    FROM public.ledger_entries
    WHERE organisation_id = p_organisation_id AND type = 'Debit';

    RETURN total_credit - total_debit;
END;
$$ LANGUAGE plpgsql;
